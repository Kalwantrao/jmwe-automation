import groovy.json.JsonSlurper
import java.nio.file.Paths

buildscript {
    def gintVersion = findProperty('gintVersion') ?: System.getenv('GINT_VERSION') ?: '+'
    dependencies {
        classpath 'org.gint:gint-atlassian:' + gintVersion
    }
    repositories {
        flatDir { dirs 'libs' } // for testing SNAPSHOT versions
        mavenLocal()
        mavenCentral()
        maven { url 'https://plugins.gradle.org/m2/' }
    }
}
apply plugin: 'org.gint.atlassian'
apply from: 'common/setUp.gradle'
apply from: '../../common/commonMethod.gradle'

def info = gint.getJiraHelper().getServerInfoWithVerify() // Verify access to Jira instance otherwise end test if server not available
def project = gint.getJiraHelper().getProjectKey()	//get project key using jira helper functions
def transition = 'assignIssuePostfunction'
def workflow = project
def screen = project
def user = info?.user
def userId = 'jmwe_qa'
def projectRole = 'jmwe_role'
def userGroup = 'jmwe_group'

gint.xmlReport = true	//xml report generates in projects root directory
gint.verbose = true

def jsonSlurper = new JsonSlurper();
def path = Paths.get(gint.directories.resource + "/resources/postfunctionsData/AssignIssuePostfunction${info?.isCloud ? "Cloud" : ""}.json")
def transitionFunctions = jsonSlurper.parse(path)
def functionKey = 'com.innovalog.jmwe.jira-misc-workflow-extensions:AssignIssue-function'
def startStep = info?.isCloud ? '1':'11' // depends on workflow. '1' for cloud and '11' (To Do)for server works for custom jira workflow

createTransitionsWithFunctions(transitionFunctions, transition, functionKey, 'postfunction', startStep, workflow, screen, 0)

// check current issue should be assigned to  current user
def currentIssue = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'createCurrentIssue')
transitionIssue(transition+0, {-> currentIssue[0]}, 0, 'currentIssueShouldBeAssignedToCurrentUser')
getIssueInformation({-> currentIssue[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'currentIssueAssignedToCurrentUser')

// check the subtask of the parent issue should be assigned to current user
def parent = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'createParentIssue')
def subTask = createIssue(project,{[ type: 'Sub-task', summary: 'JMWE_Issue', parent: {-> parent[0]} ]}, 'createSubtask')
transitionIssue(transition+1, {-> parent[0]}, 0, 'subtaskOfParentIssueShouldBeAssignToCurrentUser')
getIssueInformation({-> subTask[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'subtaskOfParentIssueAssignedToCurrentUser')

// check the parent issue of the current subtask should be assigned to current user
transitionIssue(transition+2, {-> subTask[0]}, 0, 'parentIssueOfSubtaskShouldBeAssignToCurrentUser')
getIssueInformation({-> parent[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'parentIssueOfCurrentSubtaskAssignedToCurrentUser')

// check the issue belongs to current epic should be assigned to current user
def epic = createIssue(project,{[ type: 'epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Epic"]}, 'createEpic')
def story = createIssue(project,{[ type: 'story', summary: 'JMWE_Issue', field: "Epic Link", value: {-> epic[0]} ]}, 'createStory')
transitionIssue(transition+3, {-> epic[0]}, 0, 'issueBelongsToCurrentEpicShouldBeAssignToCurrentUser')
getIssueInformation({-> story[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'issueBelongsToCurrentEpicAssignedToCurrentUser')

// check the epic of the current issue should be assigned to current user
transitionIssue(transition+4, {-> story[0]}, 0, 'epicOfTheCurrentIssueShouldBeAssignToCurrentUser')
getIssueInformation({-> epic[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'epicOfCurrentissueAssignedToCurrentUser')

def linkIssue1 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueAnyType1')
def linkIssue2 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueAnyType2')
linkIssues([issue: { -> linkIssue1[0] }, toIssue: { -> linkIssue2[0] }, link: 'duplicates'], 'linkByAnyLinkType' )

//check the issue link by any link type to current issue should be assigned to current user
transitionIssue(transition+5, {-> linkIssue1[0]}, 0, 'issuesLinkedToCurrentIssueByAnyLinkTypeShouldBeAssignedToCurrentUser')
getIssueInformation({-> linkIssue2[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'issuesLinkedToCurrentIssueByAnyLinkTypeAssignedToCurrentUser')

def linkIssue3 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueBlocksType1')
def linkIssue4 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueBlocksType2')
linkIssues([issue: { -> linkIssue3[0] }, toIssue: { -> linkIssue4[0] }, link: 'blocks'], 'linkByBlocksLinkType' )

//check the issue link by blocks link type to current issue should be assigned to current user
transitionIssue(transition+6, {-> linkIssue3[0]}, 0, 'issuesLinkedToCurrentIssueBySpecificLinkTypeShouldBeAssignedToCurrentUser')
getIssueInformation({-> linkIssue4[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'issuesLinkedToCurrentIssueBySpecificLinkTypeAssignedToCurrentUser')

//check the issue return by groovy expression[issue.getLinkedIssues()] should be assigned to current user
transitionIssue(transition+7, {-> linkIssue3[0]}, 0, 'issuesRetunredByGroovyScriptShouldBeAssignedToCurrentUser')
getIssueInformation({-> linkIssue4[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'issuesRetunredByGroovyScriptAssignedToCurrentUser')

//check the issue return by groovy expression should be assigned to current user
def IssueReturnByJqlSearch = createIssue(project, {[type: 'Task', summary: 'JMWE_Task']}, 'jqlSearch' )
transitionIssue(transition+8, {-> linkIssue4[0]}, 0, 'issuesRetunredByJqlSearchShouldBeAssignedToCurrentUser')
getIssueInformation({-> IssueReturnByJqlSearch[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'issuesRetunredByJqlSearchAssignedToCurrentUser')

//check conditional execution = issue.get('issuetype')?.name == 'Story'
def condExecTrue = createIssue(project,{[ type: 'story', summary: 'JMWE_Issue']}, 'condExecTrue')
transitionIssue(transition+9, {-> condExecTrue[0]}, 0, 'condExecTrue')
getIssueInformation({-> condExecTrue[0]}, /Assignee  . . . . . . . . . . : ${info?.isCloud ? info?.userDisplayName : info?.user} (${info?.userKey})/, 'condExecTrue')

def condExecFalse = createIssue(project,{[ type: 'Task', summary: 'JMWE_Issue']}, 'condExecFalse')
transitionIssue(transition+9, {-> condExecFalse[0]}, 0, 'condExecFalse')
getIssueInformation({-> condExecFalse[0]}, /Assignee  . . . . . . . . . . : /, 'condExecFalse')

// check the current issue should be assigned to reporter
def issueWithReporter = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue', reporter: userId]}, 'issueWithReporter')
transitionIssue(transition+10, {-> issueWithReporter[0]}, 0, 'issueAssignedToReporter')
getIssueInformation({-> issueWithReporter[0]}, "Assignee  . . . . . . . . . . : $userId", 'issueAssignedToReporter')

// check the current user assigned to username (jmwe_qa) - JIRAUSER11602
//def assignToUsername = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'createIssueForUsername')
//transitionIssue(transition+11, {-> assignToUsername[0]}, 0, 'issueAssignedToUsername')
//getIssueInformation({-> assignToUsername[0]}, "Assignee  . . . . . . . . . . : $userId", 'issueAssignedToUsername')


