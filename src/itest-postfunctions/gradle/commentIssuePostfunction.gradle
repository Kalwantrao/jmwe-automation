import groovy.json.JsonSlurper
import java.nio.file.Paths

buildscript {
    def gintVersion = findProperty('gintVersion') ?: System.getenv('GINT_VERSION') ?: '+'
    dependencies {
        classpath 'org.gint:gint-atlassian:' + gintVersion
    }
    repositories {
        flatDir { dirs 'libs' } // for testing SNAPSHOT versions
        mavenLocal()
        mavenCentral()
        maven { url 'https://plugins.gradle.org/m2/' }
    }
}

apply plugin: 'org.gint.atlassian'
apply from: 'common/setUp.gradle'
apply from: '../../common/commonMethod.gradle'

def info = gint.getJiraHelper().getServerInfoWithVerify() // Verify access to Jira instance otherwise end test if server not available
def project = gint.getJiraHelper().getProjectKey()	//get project key using jira helper functions
def transition = 'commentIssuepf'
def workflow = project
def screen = project
def user = info.user
def userId = 'jmwe_qa'
def projectRole = 'jmwe_role'
def userGroup = 'jmwe_group'
gint.xmlReport =	true	//xml report generates in projects root directory
gint.verbose =	true

def jsonSlurper = new JsonSlurper();
def path = Paths.get(gint.directories.resource + "/resources/postfunctionsData/CommentIssuePostfunction${info?.isCloud ? "Cloud" : ""}.json")
def transitionFunctions = jsonSlurper.parse(path)
def functionKey =	info ?.isCloud ? 'com.innovalog.jmwe.jira-misc-workflow-extensions:commentIssue-function' : 'com.innovalog.jmwe.jira-misc-workflow-extensions:commentIssue-function'
def startStep = info?.isCloud ? '1':'11' // depends on workflow. '1' for cloud and '11' (To Do)for server works for custom jira workflow

createTransitionsWithFunctions(transitionFunctions, transition, functionKey, 'postfunction', startStep, workflow, screen, 0)

// check current issue
def currentIssue = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'createCurrentIssue')
transitionIssue(transition+0, {-> currentIssue[0]}, 0, 'commentCurrentIssue')
getComments({-> currentIssue[0]}, [0], user, 'commentAddedToCurrentIssue')

// check the subtask of the parent issue
def parent = createIssue(project,{[ type: 'Task', summary: 'JMWE_Issue']}, 'createParentIssue')
def subTask = createIssue(project,{[ type: 'Sub-task', summary: 'JMWE_Issue', parent: {-> parent[0]} ]}, 'createSubtask')
transitionIssue(transition+1, {-> parent[0]}, 0, 'commentToSubtask')
getComments({-> subTask[0]}, [0], user, 'commentAddedToSubtask')

// check the parent issue of the current subtask
transitionIssue(transition+2, {-> subTask[0]}, 0, '--commentAddedToParentIssue')
getComments({-> parent[0]}, [0], user, 'commentAddedToParentIssue')

// check the issue belongs to current epic
def epic = createIssue(project,{[ type: 'epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Epic"]}, 'createEpic')
def story = createIssue(project,{[ type: 'story', summary: 'JMWE_Issue', field: "Epic Link", value: {-> epic[0]} ]}, 'createStory')
transitionIssue(transition+3, {-> epic[0]}, 0, 'commentAddedToStoryOfEpic')
getComments({-> story[0]}, [0], user, 'commentAddedToStoryOfEpic')

// check the epic of the current issue
transitionIssue(transition+4, {-> story[0]}, 0, 'commentAddedToEpicOfStory')
getComments({-> epic[0]}, [0], user, 'commentAddedToEpicOfStory')

def linkIssue1 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueAnyType1')
def linkIssue2 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueAnyType2')
linkIssues([issue: { -> linkIssue1[0] }, toIssue: { -> linkIssue2[0] }, link: 'duplicates'], 'linkByAnyLinkType' )

//check the issue link by any link type to current issue
transitionIssue(transition+5, {-> linkIssue1[0]}, 0, 'commentAddedToIssuesLinkByAnyLinkType')
getComments({-> linkIssue2[0]}, [0], user, 'commentAddedToIssuesLinkByAnyLinkType')

def linkIssue3 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueBlocksType1')
def linkIssue4 = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'linkIssueBlocksType2')
linkIssues([issue: { -> linkIssue3[0] }, toIssue: { -> linkIssue4[0] }, link: 'blocks'], 'linkByBlocksLinkType' )

//check the issue link by blocks link type to current issue
transitionIssue(transition+6, {-> linkIssue3[0]}, 0, 'commentAddedToIssuesLinkByBlocksLinkType')
getComments({-> linkIssue4[0]}, [0], user, 'commentAddedToIssuesLinkByBlocksLinkType')

// check the issue return by groovy expression[issue.getLinkedIssues()]
transitionIssue(transition+7, {-> linkIssue3[0]}, 0, 'commentAddedToIssuesReturnedByGroovyScript')
getComments({-> linkIssue4[0]}, [0], user, 'commentAddedToIssuesReturnedByGroovyScript')

//check the issue return by groovy expression
def IssueReturnByJqlSearch = createIssue(project, {[type: 'Task', summary: 'JMWE_Task']}, 'jqlSearch' )
transitionIssue(transition+8, {-> linkIssue4[0]}, 0, 'commentShouldBeAddToIssuesReturnedByJqlSearch')
getComments({-> IssueReturnByJqlSearch[0]}, [0], user, 'commentAddedToIssuesReturnedByJqlSearch')

// checkCommentVisibleToGroups
def commentVisibleToGroups = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'commentVisibleToAdminGroups')
transitionIssue(transition+9, {-> commentVisibleToGroups[0]}, 0, 'commentShouldBeVisibleToJiraAdminsGroup')
checkCommentVisibleToUser( {-> commentVisibleToGroups[0]}, userId, user, 'commentVisibleToJiraAdminsGroup')

// checkCommentVisibleToProjectRoles
def  commentVisibleToAdminProjectRoles = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue']}, 'commentVisibleToAdminProjectRoles')
transitionIssue(transition+10, {-> commentVisibleToAdminProjectRoles[0]}, 0, 'commentVisibleToAdminProjectRoles')
checkCommentVisibleToUser( {-> commentVisibleToAdminProjectRoles[0]}, userId, user, 'commentVisibleToAdminProjectRoles')

// runAsUser
def runAsUser = createIssue(project,{[ type: 'Bug', summary: 'JMWE_Issue_User']}, 'runAsUser')
transitionIssue(transition+11, {-> runAsUser[0]}, 0, 'runAsUser')
//checkCommentVisibleToUser( {-> runAsUser[0]}, userId, userId, 'runAsUser')

// check conditional execution (issue.get('issuetype')?.name == 'Story') returns true for issue
def condExecTrue = createIssue(project,{[ type: 'story', summary: 'JMWE_Issue']}, 'createStoryForConditionalExcution')
transitionIssue(transition+12, {-> condExecTrue[0]}, 0, 'commentIssueIfConditionalExecTrue')
getComments({-> condExecTrue[0]}, 0, user, 'commentAddedToIssueConditionalExecTrue')














/*
ext.checkCommentVisibleToUser([transition+10], userId, user, project,  0)
def subtaskParentIssueSummary = [
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
]
def bug = createIssue(project, subtaskParentIssueSummary.collect{[ type: 'Bug', summary: it, affectsVersions: '1', labels: 'clearLabel', description: 'clearThisDescription']} )
def subTask = createIssue(project, [ 0, 1 ].collect{[type: 'Sub-Task', summary: 'summary', parent: { -> bug[it] }, components: 'component1']})
linkIssues({[ issue: { -> bug[3] }, toIssue: { -> bug[2] }, link: 'blocks'] } )

def storyEpicSummary = [
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue',
        'JMWE_Issue'
]
def epic = createIssue(project, storyEpicSummary.collect{[type: 'Epic', summary: it, field: "Epic Name", value: "Epic" ]})
def story = createIssue(project, [0, 1, 1 ].collect{[type: 'story', summary: 'summary',field: "Epic Link", value: { -> epic[it] }, fixVersions: '2', affectsVersions: '2']})

def summaryJql = [ 'jqlSearch1', 'jqlSearch2' ]
def IssueReturnByJqlSearch = createIssue(project, summaryJql.collect{[type: 'Task', summary: it, labels: 'clearLabel'] } )

def commentIssuePostfunctionsTestData = [
        //Check current issue
[
        issuetoTransition: { -> bug[0] }, issueToCheck: { -> bug[0] }, transition: "${transition}0",
        transitions: [
                [
                        ext: 'TC-01-addCommentToCurrentIssue', expected: [ 0 ],
                        data: { String _ -> 'addCommentToCurrentIssue' }()
                ]
        ]
],
        //check subtask of current issue
[
        issuetoTransition: { -> bug[0] }, issueToCheck: { -> subTask[0] }, transition: "${transition}1",
        transitions: [
                [
                        ext: 'TC-02-addCommentToSubtaskOfCurrentIssue', expected: [ 0 ],
                        data: { String _ -> 'addCommentToSubtaskOfCurrentIssue' }()
                ]
        ]
],
        // check parent issue of current subtask
[
        issuetoTransition: { -> subTask[0] }, issueToCheck: { -> bug[0] }, transition: "${transition}2",
        transitions: [
                [
                        ext: 'TC-03-addCommentToParentIssueOfSubtask', expected: [ 0 ],
                        data: { String _ -> 'addCommentToParentIssueOfSubtask' }()
                ]
        ]
],
        //check issue belongs to current epic
[
        issuetoTransition: { -> epic[0] }, issueToCheck: { -> story[0] }, transition: "${transition}3",
        transitions: [
                [
                        ext: 'TC-04-addCommentToIssueBelongToCurrentEpic', expected: [ 0 ],
                        data: { String _ -> 'addCommentToIssueBelongToCurrentEpic' }()
                ]
        ]
],
        //check epic of the current issue
[
        issuetoTransition: { -> story[1] }, issueToCheck: { -> epic[1] }, transition: "${transition}4",
        transitions: [
                [
                        ext: 'TC-05-addCommentToEpicOfTheCurrentIssue', expected: [ 0 ],
                        data: { String _ -> 'addCommentToEpicOfTheCurrentIssue' }()
                ]
        ]
],
        //check issues linked to current issue through any link type
[
        issuetoTransition: { -> bug[2] }, issueToCheck: { -> bug[3] }, transition: "${transition}5",
        transitions: [
                [
                        ext: 'TC-06-addCommentToIssuesLinkedThroughAnyLinkTypeToCurrentIssue', expected: [ 0 ],
                        data: { String _ -> 'addCommentToIssuesLinkedThroughAnyLinkTypeToCurrentIssue' }()
                ]
        ]
],
        //check issues linked to current issue through specific link type
[
        issuetoTransition: { -> bug[3] }, issueToCheck: { -> bug[2] }, transition: "${transition}6",
        transitions: [
                [
                        ext: 'TC-07-addCommentToIssuesLinkedThroughBlocksLinkTypeToCurrentIssue', expected: [ 0 ],
                        data: { String _ -> 'addCommentToIssuesLinkedThroughBlocksLinkTypeToCurrentIssue' }()
                ]
        ]
],
        //check issues return by groovy script
[
        issuetoTransition: { -> bug[3] }, issueToCheck: { -> bug[2] }, transition: "${transition}7",
        transitions: [
                [
                        ext: 'TC-08-addCommentToIssuesReturnByGroovyScript', expected: [ 0 ],
                        data: { String _ -> 'addCommentToIssuesReturnByGroovyScript' }()
                ]
        ]
],
        //check issues return by jql search
[
        issuetoTransition: { -> IssueReturnByJqlSearch[0] }, issueToCheck: { -> IssueReturnByJqlSearch[1] }, transition: "${transition}8",
        transitions: [
                [
                        ext: 'TC-09-addCommentToIssuesReturnByJqlSearch', expected: [ 0 ],
                        data: { String _ -> 'addCommentToIssuesReturnByJqlSearch' }()
                ]
        ]
],
        // check comment visible to only jira admins
[
        issuetoTransition: { -> bug[4] }, issueToCheck: { -> bug[4] }, transition: "${transition}9",
        transitions: [
                [
                      ext: 'TC-10-checkCommentVisibleToJiraAdminGroups', expected: [ 0 ],
                      data: { String _ -> 'commentVisibleToJiraAdmins' }()
                ]
        ]
],
        //check comments visible to Admin project roles
[
        issuetoTransition: { -> bug[4] }, issueToCheck: { -> bug[4] }, transition: "${transition}10",
        transitions: [
                [
                      ext: 'TC-11-checkCommentVisibleToJiraAdminRoles', expected: [ 0 ],
                      data: { String _ -> "'commentVisibleToJiraAdminsGroup','commentVisibleToJiraAdminsRole'" }()
                ]
        ]
],
        //check run as specific user
[
        issuetoTransition: { -> bug[5] }, issueToCheck: { -> bug[5] }, transition: "${transition}11",
        transitions: [
                [
                       ext: 'TC-12-checkRunAsUser', expected: [ 0 ],
                       data: { String _ -> "${userId} added a comment" }()
                ]
        ]
],
        //check conditional execution
[
        issuetoTransition: { -> bug[2] }, issueToCheck: { -> bug[2] }, transition: "${transition}12",
        transitions: [
                [
                       ext: 'TC-13(A)-conditionalExecution', expected: [ 0 ],
                       data: { String _ -> "" }()
                ]
        ]
],
        //check conditional execution
[
         issuetoTransition: { -> story[2] }, issueToCheck: { -> story[2] }, transition: "${transition}12",
         transitions: [
                 [
                       ext: 'TC-13(B)-checkConditionalExecution', expected: [ 0 ],
                       data: { String _ -> "conditionalExecution" }()
                 ]
         ]
],
]

// transition issue to check execution of transition function on issues
gint.taskHelper.add('transitionIssues',
    commentIssuePostfunctionsTestData.collect {
        def currentIssue= it['issuetoTransition']
        def currentTransition= it['transition']
        it['transitions'].collect {trans ->
            [
                    action: 'transitionIssue',
                    ext: "${trans['ext']}-${currentTransition}",
                    expected: trans['expected'],
                    dependsOn: true,
                    parameters: [
                            issue: currentIssue,
                            transition: currentTransition
                    ] + (trans['additionalParams'] != null ? trans['additionalParams'] : [:]),
            ]
        }
    }.flatten()
)
// Get issue to compare the issue fields expected and actual
gint.taskHelper.add('test',
    commentIssuePostfunctionsTestData.collect {
        def currentIssue= it['issueToCheck']
        it['transitions'].collect { get ->
            [
                    action: 'getComments',
                    ext: "${get['ext']}",
                    expected: get['expected'],
                    dependsOn: true,
                    parameters: [
                            issue: currentIssue,
                    ],
                    data: ( get['data'] == null ? get['failData'] : [:])
            ]
        }
    }.flatten()
)
 */
