import groovy.json.JsonSlurper
import java.nio.file.Paths

buildscript {
    def gintVersion = findProperty('gintVersion') ?: System.getenv('GINT_VERSION') ?: '+'
    dependencies {
        classpath 'org.gint:gint-atlassian:' + gintVersion
    }
    repositories {
        flatDir { dirs 'libs' }
        mavenLocal()
        mavenCentral()
        maven { url 'https://plugins.gradle.org/m2/' }
    }
}

apply plugin: 'org.gint.atlassian'
apply from: 'common/setUp.gradle'

def info = gint.getJiraHelper().getServerInfoWithVerify() // Verify access to Jira instance otherwise end test if server not available
def project = gint.getJiraHelper().getProjectKey()	//get project key using jira helper functions
def workflow = project
def workflowScheme = project
def screen = project
def saved =	[:]

def user = info.user
def userqa1 = project.toLowerCase()+'qa1'
def userqa2 = project.toLowerCase()+'qa2'
def userdev1 = project.toLowerCase()+'dev1'
def userdev2 = project.toLowerCase()+'dev2'
def functionKey = info?.isCloud ? '' : 'com.innovalog.jmwe.jira-misc-workflow-extensions:linkedissuesstatus-validator'	//function key for current status condition
def startStep = info?.isCloud ? "1" : "11"

def transition = 'relatedIssuesStatusValidator'
def jsonSlurper = new JsonSlurper();
def path = Paths.get(gint.directories.resource + "/resources/validatorsData/RelatedIssuesStatusValidatorFunctions${info?.isCloud ? "Cloud" : ""}.json")
//def path = Paths.get(gint.directories.resource + "/resources/validatorsData/Test${info?.isCloud ? "Cloud" : ""}.json")
def transitionFunctions = jsonSlurper.parse(path)

createTransitionsWithFunctions(transitionFunctions, 'relatedIssuesStatusValidator', functionKey, 'validator', startStep, workflow, screen, 0)
def summaries = [
		'childIssuesShouldBeInSelectedStatus',
		'checkParentIssueMustRespectGivenCondition',
		'issueLinkByAnyLinkType',
		'issueLinkByBlockLinkType',
		'issueNotReturnedByGroovy',
		'issueNotReturnedByJql',
		'issueReturnedByGroovy',
		'issueReturnedByJqlSearch'
]
def bug = createIssue(project, summaries.collect{[type: 'Bug', summary: it] } )
def subTask = createIssue(project, [1, 1 ].collect{[type: 'Sub-Task', summary: 'summary', parent: { -> bug[it] }]} )
def epic = createIssue(project, summaries.collect{[type: 'Epic', summary: it, field: "Epic Name", value: "Epic"]} )
def story = createIssue(project, [1, 1 ].collect{[type: 'story', summary: 'summary',field: "Epic Link", value: { -> epic[it] }]} )
def linktype = [ 'blocks' ]
linkIssues(linktype.collect{[ issue: { -> bug[3] }, toIssue: { -> bug[2] }, link: it] } )
def summmaryJql = [ 'jqlSearch1', 'jqlSearch2' ]
def IssueReturnByJqlSearch = createIssue(project, summmaryJql.collect{[type: 'Task', summary: it, assignee: userqa1] } )

def issueList1 = [
	0: { -> bug[1] },
    1: { -> subTask[0] },
    2: { -> bug[1] },
    3: { -> bug[1] },
    4: { -> subTask[1] },
    5: { -> bug[1] },
	6: { -> epic[1] },
    7: { -> story[0] },
    8: { -> epic[1] },
    9: { -> epic[1] },
    10: { -> story[1] },
    11: { -> epic[1] },
	12: { -> bug[2] },
    13: { -> bug[3] },
    14: { -> bug[2] },
    15: { -> bug[3] },
    16: { -> bug[2] },
    17: { -> bug[3] },
	18: { -> bug[2] },
    19: { -> bug[3] },
    20: { -> bug[2] },
    21: { -> bug[0] },
    22: { -> bug[2] },
    23: { -> bug[0] },
    24: { -> bug[2] },
    25: { -> bug[0] },
    26: { -> bug[2] },
    27: { -> bug[0] }
]
[
	0:'Remote error: issuelinks: subtask of the issue must be in selected status',
	1:'Remote error: issuelinks: parent issue must be in selected status',
	2:'Remote error: issuelinks: atleast one subtask of the issue must be in selected status',
	3:'Remote error: issuelinks: all subtask of the issue must not be in selected status',
	4:'Remote error: issuelinks: parent issue of the subtask must not be in selected status',
	5:'Remote error: issuelinks: atleast one subtask of the issue must not be in selected status',
	6:'Remote error: issuelinks: each issue belong to epic must be in selected status',
	7:'Remote error: issuelinks: epic of the issue must be in selected status',
	8:'Remote error: issuelinks: atleast one issue belong to epic must be in selected status',
	9:'Remote error: issuelinks: all issue belong to epic must not be in selected status',
	10:'Remote error: issuelinks: epic of the issue must not be in selected status',
	11:'Remote error: issuelinks: atleast one issue belong to epic must not be in selected status',
	12:'Remote error: issuelinks: all issues linked to the issue by any link type must be in selected status',
	13:'Remote error: issuelinks: all issues linked to the issue by blocks link type must be in selected status',
	14:'Remote error: issuelinks: atleast one issue linked to the issue by any link type must be in selected status',
	15:'Remote error: issuelinks: at least one issue linked to the current issue by blocks link must be in selected status',
	16:'Remote error: issuelinks: all issues link to the issue by any link type must not be in selected status',
	17:'Remote error: issuelinks: all issue linked by blocks link type must not be in selected status',
	18:'Remote error: issuelinks: at least one one issue linked by any link type must be in selected status',
	19:'Remote error: issuelinks: at least one issue linked by blocks link type must not be in selected status',
	20:'Remote error: issuelinks: all issues returned by groovy condition must be in selected status',
	21:'Remote error: issuelinks: all the issues returned by jql search must be in selected status',
	22:'Remote error: issuelinks: at least one issue returned by groovy script must be in selected status',
	23:'Remote error: issuelinks: at least one issue returned by jql search must be in selected status',
	24:'Remote error: issuelinks: issue returned by groovy condition must not be in selected status',
	25:'Remote error: issuelinks: issue return by jql search must not be in selected status',
	26:'Remote error: issuelinks: at least one issue return by groovy script must not be in selected status',
	27:'Remote error: issuelinks: at least one issue return by jql search must not be in selected status',
].eachWithIndex { data, number ->
    gint.taskHelper.add(
        [
            action: 'transitionIssue',
            ext: 'validateWhenRelatedIssueNotInSelectedStatus' + number,
            dependsOn: true,
            expected: [ -3 ],
            parameters: [
                issue: issueList1[number],
                transition: transition + number
            ],
            data: [],
        ]
    )
}

// Validate that when issues are having related issue(s) in selected status

def issueList2 = [
	28: { -> bug[1] },
    29: { -> subTask[0] },
    30: { -> bug[1] },
    31: { -> bug[1] },
    32: { -> subTask[1] },
    33: { -> bug[1] },
	34: { -> epic[1] },
    35: { -> story[0] },
    36: { -> epic[1] },
    37: { -> epic[1] },
    38: { -> story[1] },
    39: { -> epic[1] },
	40: { -> bug[2] },
    41: { -> bug[3] },
    42: { -> bug[2] },
    43: { -> bug[3] },
    44: { -> bug[2] },
    45: { -> bug[3] },
	46: { -> bug[2] },
    47: { -> bug[3] },
    48: { -> bug[2] },
    49: { -> bug[0] },
    50: { -> bug[2] },
    51: { -> bug[0] },
    52: { -> bug[2] },
    53: { -> bug[0] },
    54: { -> bug[2] },
    55: { -> bug[0] },
]
(28..55).each { number ->
    gint.taskHelper.add(
        [
            action: 'transitionIssue',
            ext: 'validateWhenRelatedIssuesInSelectedStatus' + number,
            dependsOn: true,
            expected: [ 0 ],
            parameters: [
                issue: issueList2[number],
                transition: transition + number
            ],
            data:[
            	~/Successfully transitioned issue ${project}-\d+ with transition '${transition + number}'./
             ]
		])
}
