buildscript {
	repositories {
		maven {
			url "https://plugins.gradle.org/m2/"
		}
	}
	dependencies {
		classpath "org.gint:gint-atlassian:3.8.4"
	}
}

apply plugin: 'org.gint.atlassian'
apply from: gint.resourceDirectory +'/src/common/utils.gradle'

tearDown()
addWorkflow()

def functionKey = info?.isCloud? functionKey.relatedIssuesConditionCloud : functionKey.relatedIssuesConditionServer

project.ext.relatedIssueFields_default_server = [
		"maxLinkedIssues=",
		"minLinkedIssues=1",
		"conditionMode=requireLinks",
		"groovyExpression=",
		"checkAllLinkedIssues=yes",
		"correlationId="
]

def relatedIssue = info?.isCloud ? requireRelatedIssuesFieldsCloud : relatedIssueServer

def fieldsToRemove = ["currentIssue", "parentIssue", "epicOfTheCurrentIssue","parentPortfolio"]

fieldsToRemove.each { key ->
	relatedIssue.remove(key)
}

relatedIssue.eachWithIndex { key, value, i ->
	def defaultFieldsCloud = ["condition.id=9def4812-c8d0-45eb-9903-21dcbe2a70be"]
	def targetIssueString = new groovy.json.JsonBuilder(value).toString()
	def targetIssue = "condition.config-9def4812-c8d0-45eb-9903-21dcbe2a70be=${targetIssueString}"

	defaultFieldsCloud.add(targetIssue)

	def transition = 'relatedIssueCondition_requireLinks'
	def fields = info?.isCloud? defaultFieldsCloud.each{element -> element } : relatedIssueFields_default_server + "selectedLinkType=$value"
	addTransitionFunction(transition + i, 'condition', fields, functionKey)
}
/*
relatedIssue.eachWithIndex { key, value, i ->
	relatedIssueFields_default_server[3] = "groovyExpression=$groovyExpression.checkPriorityHigh"
	relatedIssueFields_default_server[2] = "conditionMode=checkLinks"
	def transition = 'relatedIssueCondition_checkLinks'
	def fields = info?.isCloud? defaultFieldsCloud.each{element -> element } : relatedIssueFields_default_server + "selectedLinkType=$value"
	addTransitionFunction( transition + i, 'condition', fields, functionKey)
}

relatedIssue.eachWithIndex { key, value, i ->
	def defaultFieldsCloud = ["condition.id=9def4812-c8d0-45eb-9903-21dcbe2a70be"]
	def targetIssueString = new groovy.json.JsonBuilder(targetIssueFieldsMap).toString()
	def targetIssue = "condition.config-9def4812-c8d0-45eb-9903-21dcbe2a70be=${targetIssueString}"

	defaultFieldsCloud.add(targetIssue)

	relatedIssueFields_default_server[2] = "conditionMode=forbidLinks"
	relatedIssueFields_default_server[3] = "groovyExpression=$groovyExpression.checkPriorityHigh"
	def transition = 'relatedIssueCondition_forbidLinks'
	def fields = info?.isCloud? defaultFieldsCloud.each{element -> element } : relatedIssueFields_default_server + "selectedLinkType=$value"
	addTransitionFunction(transition + i, 'condition', fields, functionKey)
}

relatedIssue.take(2).eachWithIndex { key, value, i ->
	def transition = 'relatedIssueCondition_issueConstraintsFalse'
	relatedIssueFields_default_server[2] = "conditionMode=requireLinks"
	relatedIssueFields_default_server[0] = "maxLinkedIssues=2"
	relatedIssueFields_default_server[1] = "minLinkedIssues=2"
	def fields = info?.isCloud? "" : relatedIssueFields_default_server + "selectedLinkType=$value"
	addTransitionFunction(transition + i, 'condition', fields, functionKey)
}

relatedIssue.take(2).eachWithIndex { key, value, i ->
	def transition = 'relatedIssueCondition_issueConstraintsTrue'
	relatedIssueFields_default_server[2] = "conditionMode=requireLinks"
	relatedIssueFields_default_server[0] = "maxLinkedIssues=5"
	relatedIssueFields_default_server[1] = "minLinkedIssues=2"
	def fields = info?.isCloud? "" : relatedIssueFields_default_server + "selectedLinkType=$value"
	addTransitionFunction(transition + i, 'condition', fields, functionKey)
}

['issueReturnFromJqlSearch_require'].each {
	def transition = 'relatedIssueCondition_issueConstraintsTrue'
	relatedIssueFields_default_server[2] = "conditionMode=requireLinks"
	relatedIssueFields_default_server[0] = "maxLinkedIssues="
	relatedIssueFields_default_server[1] = "minLinkedIssues=1"
	relatedIssueFields_default_server[3] = "groovyExpression="
	def fields = info?.isCloud? "" : relatedIssueFields_default_server + "selectedLinkType=jql:project = $projectName AND summary ~ JQL_ISSUE"
	addTransitionFunction(it, 'condition', fields, functionKey)
}

['issueReturnFromJqlSearch_check'].each {
	def transition = 'relatedIssueCondition_issueConstraintsTrue'
	relatedIssueFields_default_server[0] = "maxLinkedIssues="
	relatedIssueFields_default_server[1] = "minLinkedIssues=1"
	relatedIssueFields_default_server[2] = "conditionMode=checkLinks"
	relatedIssueFields_default_server[3] = "groovyExpression=$groovyExpression.checkPriorityHigh"
	def fields = info?.isCloud? "" : relatedIssueFields_default_server + "selectedLinkType=jql:project = $projectName AND summary ~ JQL_ISSUE"
	addTransitionFunction( it, 'condition', fields, functionKey)
}
['issueReturnFromJqlSearch_forbid'].each {
	def transition = 'relatedIssueCondition_issueConstraintsTrue'
	relatedIssueFields_default_server[0] = "maxLinkedIssues="
	relatedIssueFields_default_server[1] = "minLinkedIssues=1"
	relatedIssueFields_default_server[2] = "conditionMode=forbidLinks"
	relatedIssueFields_default_server[3] = "groovyExpression=$groovyExpression.checkPriorityHigh"
	def fields = info?.isCloud? "" : relatedIssueFields_default_server + "selectedLinkType=jql:project = $projectName AND summary ~ JQL_ISSUE"
	addTransitionFunction(it, 'condition', fields, functionKey)
}

 */
createWorkflowScheme()
createProject()

def defaultIssue = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'default')
def parent = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'parent')
def subtask = createIssue([type: 'Sub-task', summary: 'JMWE_Issue', parent: { -> parent[] }], 'Sub-task')
def subtask2 = createIssue([type: 'Sub-task', summary: 'JMWE_Issue', parent: { -> parent[] }, priority: 'High'], 'Sub-task2')
def subtask3 = createIssue([type: 'Sub-task', summary: 'JMWE_Issue', parent: { -> parent[] },priority: 'High'], 'Sub-task3')
def epic = createIssue([type: 'Epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Issue"], 'Epic')
def issueBelongsToEpic = createIssue([type: 'Task', summary: 'JMWE_Issue', field: "Epic Link", value: {->epic[]}], 'BelongsToEpic')
def issueBelongsToEpic2 = createIssue([type: 'Task', summary: 'JMWE_Issue', field: "Epic Link", value: {->epic[]}, priority: 'High'], 'BelongsToEpic2')
def issueBelongsToEpic3 = createIssue([type: 'Task', summary: 'JMWE_Issue', field: "Epic Link", value: {->epic[]}, priority: 'High'], 'BelongsToEpic3')
def initiative = createIssue([type: 'Initiative', summary: 'JMWE_Issue'], 'Initiative')
def epic_initiative = createIssue([type: 'Epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Issue"], 'Epic_initiative')
def epic_initiative2 = createIssue([type: 'Epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Issue", priority: 'High'], 'Epic_initiative2')
def epic_initiative3 = createIssue([type: 'Epic', summary: 'JMWE_Issue', field: "Epic Name", value: "JMWE_Issue", priority: 'High'], 'Epic_initiative3')
def issueLinks = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'issueLinks')
def blocks = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'blocks')
def clones = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'clones')
def duplicates = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'duplicates')
def relatesTo = createIssue([type: 'Task', summary: 'JMWE_Issue'], 'relatesTo')
def jqlIssue = createIssue([type: 'Task', summary: 'JQL_ISSUE'], 'jqlIssue')

updateIssue([issue: {->epic_initiative[]}, field: "Parent Link", value: {->initiative[]}], "parent initiative child epic")

def linkIssuesMap = [
		blocks : {->blocks[]},
		clones : {->clones[]},
		duplicates : {->duplicates[]},
		'relates to': {->relatesTo[]}
]
linkIssuesMap.eachWithIndex { key, value, i ->
	linkIssue([issue: {->issueLinks[]}, toIssue: value, link: "$key"], key)
}

def relatedIssuesMapServer = [
		{->parent[]}: {->subtask[]},
		{->epic[]}: {->issueBelongsToEpic[]},
		{-> initiative[]} : {->epic_initiative[]},
		{->issueLinks[]} : {->blocks[]},
		{->issueLinks[]} : {->blocks[]},
		{->blocks[]} : {->issueLinks[]},
		{->issueLinks[]} : {->clones[]},
		{->clones[]} : {->issueLinks[]},
		{->issueLinks[]} : {->duplicates[]},
		{->duplicates[]} : {->issueLinks[]},
		{->issueLinks[]} : {->relatesTo[]},
		{->issueLinks[]} : {->relatesTo[]},
		{->issueLinks[]} : {->relatesTo[]},
]
def relatedIssuesMapCloud = [
		{->parent[]}: {->subtask[]},
		{->epic[]}: {->issueBelongsToEpic[]},
		{->issueLinks[]} : {->blocks[]},
		{->issueLinks[]} : {->blocks[]},
		{->blocks[]} : {->issueLinks[]},
		{->issueLinks[]} : {->clones[]},
		{->clones[]} : {->issueLinks[]},
		{->issueLinks[]} : {->duplicates[]},
		{->duplicates[]} : {->issueLinks[]},
		{->issueLinks[]} : {->relatesTo[]},
]
def relatedIssuesMap = info?.isCloud ? relatedIssuesMapCloud : relatedIssuesMapServer
relatedIssue.remove("returnsFromJqlSearch")

[
		'relatedIssueCondition_requireLinks',
 		/*'relatedIssueCondition_forbidLinks',*/
].collect {
	relatedIssuesMap.eachWithIndex { key, value, i ->
		gint.taskHelper.add([
				[action    : 'transitionIssue', ext: ': issue has linked issues :'+ it + i,
						sleep: 3000,
				 expected: 0,
				 parameters: [
						 issue     : key,
						 transition: it + i,
				 ]
				],
		])
	}
}

// When issue not having related issues or issues linked to it through specific link types

[
		'relatedIssueCondition_requireLinks',
].collect {
	relatedIssue.eachWithIndex { key, value, i ->
		gint.taskHelper.add([
				[action    : 'transitionIssue', ext: ': issue not has linked issues_checkRequireLinks :' + it +i,
				 sleep: 3000,
				 expected  : -1,
				 parameters: [
						 issue     : { -> defaultIssue[] },
						 transition: it + i,
				 ]
				],
		])
	}
}
/*
[
		'relatedIssueCondition_checkLinks',
].collect {
	relatedIssue.eachWithIndex { key, value, i ->
		gint.taskHelper.add([
				[action    : 'transitionIssue', ext: ': issue not has linked issues_checkLinks :' + it +i,
				 expected  : 0,
				 parameters: [
						 issue     : { -> defaultIssue[] },
						 transition: it + i,
				 ]
				],
		])
	}
}

[
		'relatedIssueCondition_checkLinks',
].collect {
	relatedIssuesMap.eachWithIndex { currentIssue, targetIssue, i ->
		gint.taskHelper.add([
				[action    : 'transitionIssue', ext: ': issue not has linked issues following given constraints_checkLinks :'+ it + i,
				 expected: -1,
				 parameters: [
						 issue     : currentIssue,
						 transition: it + i,
				 ]
				],
		])
	}
}

[
		/'relatedIssueCondition_checkLinks',
].collect {
	relatedIssuesMap.eachWithIndex { currentIssue, targetIssue, i ->
		gint.taskHelper.add([
				[action: 'updateIssue', ext: ': set priority to High_targetIssue:' + it + i,
				parameters:[
					 issue: targetIssue,
					 priority: 'High'
					]
				],
				[action: 'updateIssue', ext: ': set priority to High_currentIssue:' + it + i,
				 parameters:[
						 issue: currentIssue,
						 priority: 'High'
				 ]
				],
				[action    : 'transitionIssue', ext: ': issue has linked issues following given constraints_requireLinks :'+ it + i,
				 expected: 0,
				 parameters: [
						 issue     : currentIssue,
						 transition: it + i,
				 ]
				],
		])
	}
}
[
		'relatedIssueCondition_forbidLinks'
].collect {
	relatedIssuesMap.eachWithIndex { currentIssue, targetIssue, i ->
		gint.taskHelper.add([
				[action: 'updateIssue', ext: ': set priority to High_currentIssue:' + it + i,
				 parameters:[
						 issue: currentIssue,
						 priority: 'High'
				 ]
				],
				[action    : 'transitionIssue', ext: ': issue has linked issues following given constraints_forbid :'+ it + i,
				 expected: -1,
				 parameters: [
						 issue     : currentIssue,
						 transition: it + i,
				 ]
				],
		])
	}
}
[
		'relatedIssueCondition_issueConstraintsFalse'
].collect {
	relatedIssuesMap.take(2).eachWithIndex { currentIssue, targetIssue, i ->
		gint.taskHelper.add([
			[action    : 'transitionIssue', ext: ': issue not has linked issues following given constraints_no of Issues :' + it + i,
			 expected  : -1,
			 parameters: [
					 issue     : currentIssue,
					 transition: it + i,
				 ]
			],
		])
	}
}
[
		'relatedIssueCondition_issueConstraintsTrue'
].collect {
	relatedIssuesMap.take(2).eachWithIndex { currentIssue, targetIssue, i ->
		gint.taskHelper.add([
			[action    : 'transitionIssue', ext: ': issue has linked issues following given constraints_no of Issues :' + it + i,
			 expected  : 0,
			 parameters: [
					 issue     : currentIssue,
					 transition: it + i,
			 ],
			],
	])
	}
}


[
		'issueReturnFromJqlSearch_require',
].collect {
		gint.taskHelper.add([
				[action    : 'transitionIssue', ext: ': atleast one issue found by jql search summary_JQL_ISSUE_requireLinks:'+ it,
				 expected: 0,
				 parameters: [
						 issue     : { ->jqlIssue[] },
						 transition: it,
				 ]
				],
				[action: 'updateIssue', ext: ': change summary_requireLinks:' + it,
						sleepAfter: 2000,
				 parameters:[
						 issue: { ->jqlIssue[] },
						 summary: 'Invalid',
						 priority: 'High',
				 ]
				],
				[action    : 'transitionIssue', ext: ': when jql search does not return atleast one issue_requireLinks :'+ it,
				 expected: -1,
				 parameters: [
						 issue     : { ->jqlIssue[] },
						 transition: it,
				 ]
				],
		])
}

[		'issueReturnFromJqlSearch_check',
].each {
	gint.taskHelper.add([
			[action: 'updateIssue', ext: ': change summary for check issues_CheckLinks:' + it,
			 parameters:[
					 issue: { ->jqlIssue[] },
					 summary: 'JQL_ISSUE',
					 priority: 'High',
			 ]
			],
			[action    : 'transitionIssue', ext: ': when jql search issues respecting constraints_CheckLinks:'+ it,
			 expected: 0,
			 parameters: [
					 issue     : { ->jqlIssue[] },
					 transition: it,
			 ]
			],
			[action: 'updateIssue', ext: ': change priority to check issues_CheckLinks:' + it,
			 parameters:[
					 issue: { ->jqlIssue[] },
					 priority: 'Low',
			 ]
			],
			[action    : 'transitionIssue', ext: ': when jql search issues not respecting constraints_CheckLinks:'+ it,
			 expected: -1,
			 parameters: [
					 issue     : { ->jqlIssue[] },
					 transition: it,
			 ]
			],
	])

}
[		'issueReturnFromJqlSearch_forbid',
].each {
	gint.taskHelper.add([
			[action: 'updateIssue', ext: ': change summary for check issues_forbid:' + it,
			 parameters:[
					 issue: { ->jqlIssue[] },
					 summary: 'JQL_ISSUE',
					 priority: 'High',
			 ]
			],
			[action    : 'transitionIssue', ext: ': when jql search issues respecting constraints:'+ it,
			 expected: -1,
			 parameters: [
					 issue     : { ->jqlIssue[] },
					 transition: it,
			 ]
			],
			[action: 'updateIssue', ext: ': change priority to check issues-forbid:' + it,
			 parameters:[
					 issue: { ->jqlIssue[] },
					 priority: 'Low',
			 ]
			],
			[action    : 'transitionIssue', ext: ': when jql search issues not respecting constraints_forbid:'+ it,
			 expected: 0,
			 parameters: [
					 issue     : { ->jqlIssue[] },
					 transition: it,
			 ]
			],
	])

}

 */

/*
1. The current issue must have at least 1 sub-tasks - default config.-positive = "DONE"
2.The current issue must have at least 1 sub-tasks/issue belongs to epic = "DONE"
3.The current issue must not have any sub-task/issue belongs to epic = "DONE"
4.The current issue must have at least 2 and at most 2 sub-tasks / issue belongs to epic = "Done"
5.The current issue must have at least 2 and at most 3 sub-tasks/issue belongs to epic = Done
6.The following Groovy expression:issue.get("project")?.key == "AUTOMATION" -must return at least 2 and at most 2 issues = "Done"
7.The current issue must have at least 2 and at most 2 sub-tasks and they must all respect the following condition:issue.get("priority")?.name == "High"
  parent issue has 3 subtasks and out of 3 ,2 subtasks must be of 'High' priority = "Done"
8.The current issue must have at least 2 and at most 2 sub-tasks and they must all respect the following condition:issue.get("creator")?.name == "automation"
  create issue with defferent users as creator's and validate issues having given creator - IMPORTANT
9.
 */
